#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-g|--memoize-group GROUP] [--name NAME] [--what WHAT] [-i[SUFFIX]|--in-place[=SUFFIX]] [--ignore-nonexisting|--create-nonexisting] [--add-after ADDRESS] -m|-marker WHAT|(--begin-marker BEGIN-LINE --end-marker END-LINE) -b|--block-text BLOCK-TEXT|-B|--block-file BLOCK-FILE [...] [-a|--accept-match ACCEPT-PATTERN] [--pre-line PRETEXT [--pre-line ...]|--post-line POSTTEXT [--post-line ...]]] [FILE ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
If not at least one (all with --all) of the passed FILE(s) already contains a
sequence of lines that starts with BEGIN-LINE, ends with END-LINE and has BLOCK
contents in between, asks the user whether to update an existing sequence (in
the first file to match, and only the first such matching block there), or
append (at the end of the last FILE).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --memoize-group|-g GROUP
			    Optional application / use case for this tool's use.
			    Determines the configuration directory.
    --name|-n NAME	    Optional human-readable characterization of the
			    FILE(s) (will be used for querying and memoizing the
			    decision). Defaults to the passed FILE(s)
			    themselves.
    --what WHAT		    Optional human-readable characterization of the
			    BLOCK (will be used for querying and memoizing the
			    decision). Defaults to the --marker|-m WHAT
			    argument, if given, or "the block".
EXIT STATUS:
    0	An update has happened (with --all: in at least one FILE).
    1	The BLOCK already existed, no modifications were made.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	None of the passed FILE(s) exist; no modifications could be made.
    5	A FILE could not be created / modified (due to problems with sed).
    6	The BLOCK-FILE cannot be read.
    99	Update was declined by the user.

Example:
HELPTEXT
    printf '%q %s\n' "$(basename "$1")" '-i.bak --marker "home network" --block-file path/to/myhosts.txt /etc/hosts'
}

typeset -a addOrUpdateBlockArgs=()
typeset -a addOrUpdateBlockInplaceArg=()
typeset -a addOrUpdateBlockTestOnlyArg=()
typeset -a memoizeDecisionArgs=()
name=
isAll=
what=
markerName=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		    shift; printLongUsage "$0"; exit 0;;
	--memoize-group|-g)	    memoizeDecisionArgs+=("$1" "$2"); shift; shift;;
	--name|-n)		    shift; name="$1"; shift;;
	--what)			    shift; what="$1"; shift;;
	--in-place|--inplace=*|-i*) addOrUpdateBlockInplaceArg+=("$1"); shift;;
	--test-only|-t)		    addOrUpdateBlockTestOnlyArg+=("$1"); shift;;
	--all|-a)		    addOrUpdateBlockArgs+=("$1"); shift; isAll=t;;
	--marker|-m)		    addOrUpdateBlockArgs+=("$1" "$2"); markerName="$2"; shift; shift;;
	--begin-marker|--end-marker|--block-text|-b|--block-file|-B|--accept-match|-a|--pre-line|--post-line|--add-after)
				    addOrUpdateBlockArgs+=("$1" "$2"); shift; shift;;
	--ignore-nonexisting|--create-nonexisting)
				    addOrUpdateBlockArgs+=("$1"); shift;;
	--)			    addOrUpdateBlockArgs+=("$1"); shift; break;;
	-)			    break;;
	-*)			    { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)			    break;;
    esac
done

# Copy stdin into temporary file, as we may need to iterate over it.
if [ $# -eq 0 -o "$1" = '-' ]; then # Note: This doesn't handle a later - argument, but mixing files and stdin is rare.
    TMPFILE="$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$$RANDOM")"
    cleanup()
    {
	rm -f "$TMPFILE" 2>/dev/null
    }
    [ "${DEBUG:-}" ] || trap 'cleanup' EXIT
    cp /dev/stdin "$TMPFILE" || exit $?
    set -- "$TMPFILE"	# Note: We trust that the user didn't erroneously passed --in-place. Normally, sed would complain ("no input files" or "can't read -: No such file or directory", but as we convert into a temporary file, this doesn't happen now.
fi

# Note: Omit addOrUpdateBlockInplaceArg here, as that would conflict with
# --test-only.
addOrUpdateBlock --test-only "${addOrUpdateBlockArgs[@]}" "$@" || exit $?


verb="does not"
action="update it"
if [ $# -gt 1 ]; then
    if [ "$isAll" ]; then
	subject="All of $*"
	verb="do not"
	action="update them"
    else
	subject="At least one of $*"
    fi
else
    subject="$*"
fi
[ "$memoizeDecisionArgs" ] || memoizeDecisionArgs=(--memoize-group "$(basename -- "$0").$PPID")
memoizeDecision "${memoizeDecisionArgs[@]}" --subject "${name:-$subject}" --verb "$verb" --state "yet contain ${what:-${markerName:-the block}}" --action "$action"
status=$?
case $status in
    0)	exec addOrUpdateBlock "${addOrUpdateBlockInplaceArg[@]}" "${addOrUpdateBlockTestOnlyArg[@]}" "${addOrUpdateBlockArgs[@]}" "$@";;
    1)	exit 99;;
    *)	exit $status;;
esac
