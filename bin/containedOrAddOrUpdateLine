#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-g|--memoize-group GROUP] [--name NAME] [-i[SUFFIX]|--in-place[=SUFFIX]] [--ignore-nonexisting|--create-nonexisting] [--add-after ADDRESS] -l|--line LINE [-a|--accept-match ACCEPT-PATTERN -u|--update-match PATTERN [-r|--replacement REPLACEMENT] [--pre-line PRETEXT [--pre-line ...]|--post-line POSTTEXT [--post-line ...]]] [FILE ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
If the passed LINE / PATTERN does not exist / match in at least one (all with
--all) of the passed FILE(s), asks the user whether to update with REPLACEMENT
(in the first to match), or append (in the last FILE).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --memoize-group|-g GROUP
			    Optional application / use case for this tool's use.
			    Determines the configuration directory.
    --name|-n NAME	    Optional human-readable characterization of the
			    FILE(s) (will be used for querying and memoizing the
			    decision). Defaults to the passed FILE(s) themselves.
EXIT STATUS:
    0	An update has happened (with --all: in at least one FILE).
    1	The LINE already existed, no modifications were made.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	None of the passed FILE(s) exist; no modifications could be made.
    5	A FILE could not be created / modified (due to problems with sed).
    99	Update was declined by the user.

Example:
HELPTEXT
    printf '%q %s\n' "$(basename "$1")" '-i.bak --line "AcceptEnv FOO" /etc/ssh/sshd_config && service ssh restart'
}

typeset -a addOrUpdateLineArgs=()
typeset -a addOrUpdateLineInplaceArg=()
typeset -a addOrUpdateLineTestOnlyArg=()
typeset -a memoizeDecisionArgs=()
name=
isAll=
line=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		    shift; printLongUsage "$0"; exit 0;;
	--memoize-group|-g)	    memoizeDecisionArgs+=("$1" "$2"); shift; shift;;
	--name|-n)		    shift; name="$1"; shift;;
	--in-place|--inplace=*|-i*) addOrUpdateLineInplaceArg+=("$1"); shift;;
	--test-only|-t)		    addOrUpdateLineTestOnlyArg+=("$1"); shift;;
	--all|-a)		    addOrUpdateLineArgs+=("$1"); shift; isAll=t;;
	--line|-l)		    addOrUpdateLineArgs+=("$1" "$2"); line="$2"; shift; shift;;
	--ignore-nonexisting|--create-nonexisting)
				    addOrUpdateLineArgs+=("$1"); shift;;
	--accept-match|-a|--update-match|-u|--replacement|-r|--pre-line|--post-line|--add-after)
				    addOrUpdateLineArgs+=("$1" "$2"); shift; shift;;
	--)			    addOrUpdateLineArgs+=("$1"); shift; break;;
	-)			    break;;
	-*)			    { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)			    break;;
    esac
done

# Copy stdin into temporary file, as we may need to iterate over it.
if [ $# -eq 0 -o "$1" = '-' ]; then # Note: This doesn't handle a later - argument, but mixing files and stdin is rare.
    TMPFILE="$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$$RANDOM")"
    cleanup()
    {
	rm -f "$TMPFILE" 2>/dev/null
    }
    [ "${DEBUG:-}" ] || trap 'cleanup' EXIT
    cp /dev/stdin "$TMPFILE" || exit $?
    set -- "$TMPFILE"	# Note: We trust that the user didn't erroneously passed --in-place. Normally, sed would complain ("no input files" or "can't read -: No such file or directory", but as we convert into a temporary file, this doesn't happen now.
fi

# Note: Omit addOrUpdateLineInplaceArg here, as that would conflict with
# --test-only.
addOrUpdateLine --test-only "${addOrUpdateLineArgs[@]}" "$@" || exit $?


verb="does not"
action="update it"
if [ $# -gt 1 ]; then
    if [ "$isAll" ]; then
	subject="All of $*"
	verb="do not"
	action="update them"
    else
	subject="At least one of $*"
    fi
else
    subject="$*"
fi
[ "$memoizeDecisionArgs" ] || memoizeDecisionArgs=(--memoize-group "$(basename -- "$0").$PPID")
memoizeDecision "${memoizeDecisionArgs[@]}" --subject "${name:-$subject}" --verb "$verb" --state "yet contain '$line'" --action "$action"
status=$?
case $status in
    0)	exec addOrUpdateLine "${addOrUpdateLineInplaceArg[@]}" "${addOrUpdateLineTestOnlyArg[@]}" "${addOrUpdateLineArgs[@]}" "$@";;
    1)	exit 99;;
    *)	exit $status;;
esac
