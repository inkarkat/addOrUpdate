#!/bin/bash
shopt -qs extglob

typeset -a usageOverrideArgs=(
    -e '/^ *\(--line|-l\|--update-match|-u\|--replacement|-r\|--skip\|--no-skip\)/b removeOptionLoop'
    -e '/^Usage:$/N' -e '/\(^\|\n\)Usage: */{ s/\(^\|\n\)\(Usage: *\)\?\([^ ]\+ \)*addOrUpdateLine /\1\2'"$(basename "$0")"' -s|--section SECTION -k|--key KEY -v|--value VALUE /; s/-l|--line config line \[-a|--accept-match ACCEPT-PATTERN\] \[-u|--update-match PATTERN\] \[-r|--replacement REPLACEMENT\] //; s/\[--skip ADDRESS \[--skip ...\] \[--no-skip ADDRESS \[--no-skip ...\]\]\]//; s/\[FILE \.\.\.\]/[INI-FILE ...]/ }'
)
printUsage()
{
    addOrUpdateLine --doesNotExist 2>&1 | sed \
	-e '/^ERROR: Unknown option "--doesNotExist"!/{ N; s/\n$//; D; }' \
	"${usageOverrideArgs[@]}" \
	-e "/Try addOrUpdateLine --help for more information./s/addOrUpdateLine/$(basename "$1")/" \
	-e :removeOptionLoop
}
printLongUsage()
{
    addOrUpdateLine --help 2>&1 | sed \
	-e '1s#^.*$#'"Tries to locate a configuration in the form KEY=... under section [SECTION] in at least one (all with --all) of the passed INI-FILE(s), and updates it so that VALUE gets assigned (in the first file to match, and only the first such matching config line there), or appends (at the SECTION's end of the last INI-FILE) if such config line does not exist yet.#" \
	-e '2b removeFirstParagraphLoop' \
	-e 's/LINE/config line/g' \
	-e '/^ *--in-place/i\
    --section|-s SECTION    Locate configuration under section [SECTION].\
    --key|-k KEY	    Locate the first line that has KEY=...\
    --value|-v VALUE	    Replace the original value after the = with VALUE.' \
	"${usageOverrideArgs[@]}" \
	-e '/^Example:$/N' -e '/\(^\|\n\)Example: */{ s/\(^\|\n\)\(Example: *\)\?addOrUpdateLine .*/\1\2'"$(basename "$1") -l 'export FOO' -r quux .bashrc/ }" \
	-e b -e :removeFirstParagraphLoop -e '{ /\(^\|\n\)$/{ s/^\(.*\n\)\?//; b; }; N; b removeFirstParagraphLoop }' \
	-e b -e :removeOptionLoop -e '{ /\n *\(--line|-l\|--update-match|-u\|--replacement|-r\|--skip\|--no-skip\)[^\n]*$/{ N; b removeOptionLoop; }; /\n *--[^\n]*$\|\n[^	 ]\|\n$/{ s/^\(.*\n\)\?//; b; }; N; b removeOptionLoop }'
}

unset section
unset key
unset value
typeset -a addOrUpdateLineArgs=()
typeset -a addOrUpdatePreLineArgs=()
typeset -a addOrUpdatePreAsPostLineArgs=()
typeset -a addOrUpdateAddBeforeAfterArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--section|-s)	shift; section="${1?}"; shift;;
	--key|-k)	shift; key="${1?}"; shift;;
	--value|-v)	shift; value="${1?}"; shift;;
	--pre-line)	addOrUpdatePreLineArgs+=("$1" "${2?}")
			addOrUpdatePreAsPostLineArgs+=(--post-line "${2?}")
			shift; shift
			;;
	--add-@(before|after))
			addOrUpdateAddBeforeAfterArgs+=("$1" "${2:?}"); shift; shift;;
	--)		addOrUpdateLineArgs+=("$1"); shift; break;;
	*)		addOrUpdateLineArgs+=("$1"); shift;;
    esac
done
if [ -z "${section+t}" -o -z "${key+t}" -o -z "${value+t}" ]; then
    echo 'ERROR: All of -s|--section SECTION, -k|--key KEY and -v|--value VALUE must be passed.'
    echo
    printUsage "$0"
    exit 2
elif [ -z "$section" ]; then
    echo 'ERROR: SECTION cannot be empty.'
    echo
    printUsage "$0"
    exit 2
elif [ -z "$key" ]; then
    echo 'ERROR: KEY cannot be empty.'
    echo
    printUsage "$0"
    exit 2
fi >&2

literalKey="$(printf %s "$key" | sed -e 's/[][\$*.^]/\\&/g')"
literalSection="$(printf %s "$section" | sed -e 's/[][\$*.^/]/\\&/g')"

output="$(addOrUpdateLine \
	--skip "0,/^\\[${literalSection}\\][[:space:]]*\$/" \
	--no-skip "$;/^\\[${literalSection}\\][[:space:]]*\$/" \
	--add-after '$' \
	--add-before '/^\(\[.*\]\)\?[[:space:]]*$/' \
	"${addOrUpdateAddBeforeAfterArgs[@]}" \
	--line "${key}=${value}" --update-match "^${literalKey}=.*" \
	"${addOrUpdatePreLineArgs[@]}" "${addOrUpdateLineArgs[@]}" "$@")"; status=$?
case $status in
    1)	exec addOrUpdateLine \
		--pre-line '' \
		--line "[${section}]" \
		"${addOrUpdatePreAsPostLineArgs[@]}" \
		--post-line "${key}=${value}" \
		"${addOrUpdateLineArgs[@]}" "$@"
	;;
    *)	printf '%s\n' "$output"
	exit $status;;
esac
