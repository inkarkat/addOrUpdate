#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Tests whether the passed TEST-COMMAND succeeds with exit status 0 (any output is
discarded). If not, it asks the user whether to make it work. If confirmed, this
will execute the shell COMMANDS read from stdin.
--command|-c CMD	The command line to be tested. When this is a simple
			command, it can also be passed as such.
--recheck-at-end    will perform a second check after all COMMANDS have been
		    read; if it fails, an error is printed and this command will
		    fail.
--recheck-at-checkpoints    defines a custom "checkpoint" command that can be
			    included anywhere in COMMANDS to do a check. A
			    successful check will abort additional COMMANDS.
HELPTEXT
printf 'Usage: echo COMMANDS | %q %s\n' "$(basename "$1")" '[--bare] [--recheck-at-end] [--recheck-at-checkpoints] -c|--command "TEST-COMMANDLINE" [-c ...] | [--] SIMPLE-TEST-COMMAND [...] [-?|-h|--help]'
printf 'Usage: %q %s <<EOF\n  COMMANDS\nEOF\n' "$(basename "$1")" '[...] -c|--command "TEST-COMMANDLINE" [-c ...] | [--] SIMPLE-TEST-COMMAND [...]'
}

isNeedEval=
typeset -a commands=()
isBare=
isRecheckAtEnd=
typeset -a checkpointPrePipeline=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--bare)		shift; isBare=t;;
	--recheck-at-end)	    shift; isRecheckAtEnd=t;;
	--recheck-at-checkpoints)   shift
				    printf -v quotedTestCommandLine '%q ' "$@"
				    checkpointPrePipeline=(sed -e "1i\\checkpoint() { ${quotedTestCommandLine}>/dev/null 2>&1 && exit 0; }")
				    ;;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	commands+=(${commands:+;} $(printf '%q ' "$@"))
    else
	commands=("$@")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    exit 2
fi

(
    if [ "$isNeedEval" ]; then
	eval "${commands[@]}"
    else
	"${commands[@]}"
    fi
) >/dev/null 2>&1 && exit 0

MARKER_FILESPEC="$(echo "${TEMP:-/tmp}/$(basename -- "$0").$PPID")"

if [ -e "$MARKER_FILESPEC" ] && [ "$(find "$MARKER_FILESPEC" -mmin -15)" ]; then
    printf '%s does not succeed. Making it work.\n' "$*"
    CHOICE=y
else
    < /dev/tty read -p "$* does not succeed. Make it work? (y/n/a) " CHOICE
fi
if [ "$CHOICE" = 'a' ]; then
    touch "$MARKER_FILESPEC"
    CHOICE=y
fi

[ "$CHOICE" = 'y' ] || exit 2

runInput()
{
    if [ "$isBare" ]; then
	bash -
    else
	runWithPrompt --no-trailing-prompt
    fi
}
eval '"${checkpointPrePipeline[@]}"' "${checkpointPrePipeline:+|}" runInput
status=$?

if [ "$isRecheckAtEnd" ]; then
    if ! eval "$@" >/dev/null 2>&1; then
	printf 'ERROR: %s still does not succeed.\n' "$*"
	if [ $status -eq 0 ]; then
	    exit 1
	else
	    exit $status
	fi
    fi
fi

exit $status
