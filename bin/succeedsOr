#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: echo COMMANDLINES | %q %s\n' "$(basename "$1")" '[-g|--memoize-group GROUP] [--bare] [--recheck-at-end [--skip-after-fail-forever|--skip-after-fail-for NUMBER[SUFFIX]]] [--recheck-at-checkpoints] -c|--command "TEST-COMMANDLINE" [-c ...] [--command-name NAME] | [--] SIMPLE-TEST-COMMAND [...] [-?|-h|--help]'
    printf 'Usage: %q %s <<EOF\n  COMMANDS\nEOF\n' "$(basename "$1")" '[...] -c|--command "TEST-COMMANDLINE" [-c ...] | [--] SIMPLE-TEST-COMMAND [...]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Checks whether the passed TEST-COMMAND succeeds with exit status 0 (any output
is discarded). If not, it asks the user whether to make it work. If confirmed,
this will execute the shell COMMANDS read from stdin.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --memoize-group|-g GROUP
			    Optional application / use case for this tool's use.
			    Determines the configuration directory.
    --command|-c CMD	    The command line to be tested. When this is a simple
			    command, it can also be passed as such.
    --command-name|-n NAME  Optional human-readable characterization of COMMAND
			    that will be used for querying (and memoizing the
			    decision).
    --recheck-at-end	    will perform a second check after all COMMANDS have
			    been read; if it fails, an error is printed and this
			    command will fail.
    --recheck-at-checkpoints
			    Defines a custom "checkpoint" command that can be
			    included anywhere in COMMANDS to do a check. A
			    successful check will abort additional COMMANDS.
    --skip-after-fail-forever
			    If the recheck fails, never ask the user again, and
			    simply ignore a failing TEST-COMMAND from that
			    point.
    --skip-after-fail-for NUMBER[SUFFIX]
			    If the recheck fails, do not ask the user again
			    within the next NUMBER[SUFFIX], and ignore a failing
			    TEST-COMMAND within that interval. SUFFIX may be 's'
			    for seconds (the default), 'm' for minutes, 'h' for
			    hours or 'd' for days.
EXIT STATUS:
    0 if TEST-COMMAND succeeds or the user made it work
    1 if not, or if the check at the end fails
    2 on invocation error
    3 if memoization fails or the query times out without a given --default
    * any exit status from COMMANDS
HELPTEXT
}

isNeedEval=
commandName=
typeset -a commands=()
isBare=
typeset -a memoizeDecisionArgs=()
typeset -a failMemoizeDecisionArgs=()
isRecheckAtEnd=
isRecheckAtCheckpoints=
typeset -a checkpointPrePipeline=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		    shift; printLongUsage "$0"; exit 0;;
	--bare)			    shift; isBare=t;;
	--memoize-group|-g)	    memoizeDecisionArgs+=("$1" "$2"); shift; shift;;
	--recheck-at-end)	    shift; isRecheckAtEnd=t;;
	--recheck-at-checkpoints)   shift; isRecheckAtCheckpoints=t;;
	--skip-after-fail-forever)  shift; failMemoizeDecisionArgs=(--set-decision never);;
	--skip-after-fail-for)	    shift; failMemoizeDecisionArgs=(--set-decision no --timespan "$1"); shift;;
	--command-name|-n)	    shift; commandName="$1"; shift;;
	--command|-c)		    shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--)			    shift; break;;
	-*)			    { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)			    break;;
    esac
done
if [ $# -ne 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	commands+=(${commands:+;} $(printf '%q ' "$@"))
    else
	commands=("$@")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
    echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    echo >&2
    printUsage "$0" >&2
    exit 2
fi
if [ "$isRecheckAtCheckpoints" ]; then
    printf -v quotedTestCommandLine '%q ' "${commands[@]}"
    checkpointPrePipeline=(sed -e "1i\\checkpoint() { ${isNeedEval:+eval }${quotedTestCommandLine//\\/\\\\}>/dev/null 2>&1 && exit 0; }")
fi
[ "$memoizeDecisionArgs" ] || memoizeDecisionArgs=(--memoize-group "$(basename -- "$0").$PPID")

check()
(
    if [ "$isNeedEval" ]; then
	eval "${commands[@]}"
    else
	"${commands[@]}"
    fi >/dev/null 2>&1
)
check && exit 0

memoizeDecision "${memoizeDecisionArgs[@]}" --subject "${commandName:-${commands[*]}}" --state 'succeed' --action 'make it work' || exit $?

runInput()
{
    if [ "$isBare" ]; then
	bash -
    else
	runWithPrompt --no-trailing-prompt
    fi
}
eval '"${checkpointPrePipeline[@]}"' "${checkpointPrePipeline:+|}" runInput
status=$?

if [ "$isRecheckAtEnd" ]; then
    if ! check; then
	printf 'ERROR: %s still does not succeed.\n' "${commands[*]}"

	if [ ${#failMemoizeDecisionArgs[@]} -gt 0 ]; then
	    memoizeDecision "${memoizeDecisionArgs[@]}" --subject "${commandName:-${commands[*]}}" --action 'make it work' "${failMemoizeDecisionArgs[@]}"
	fi

	if [ $status -eq 0 ]; then
	    exit 1
	else
	    exit $status
	fi
    fi
fi

exit $status
