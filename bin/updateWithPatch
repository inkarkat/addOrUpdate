#!/bin/bash
set -o pipefail
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-i[SUFFIX]|--in-place[=SUFFIX]|-t|--test-only] [--all] [--ignore-nonexisting] [PATCH-ARGS ...] [--] PATCH [...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Updates file(s) through PATCH(es).
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --in-place[=SUFFIX]|-i[SUFFIX]
			    Edit file(s) in place (makes backup if SUFFIX
			    supplied) instead of printing to standard output.
    --test-only|-t	    Just check whether an update would be made. Does not
			    modify or create non-existing file(s), or output the
			    result.
    --all		    Instead of stopping after the first PATCH that is
			    accepted, make sure that each PATCH actually
			    applies.
    --ignore-nonexisting    Succeed instead of complaining if (none of the)
			    file(s) does not exist yet.
EXIT STATUS:
    0	An update has happened
    1	The file(s) already existed, no modifications were made.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	None (with --all: at least one) of the passed PATCH(es) could not be applied.
    5	A PATCH cannot be read.

Example:
HELPTEXT
    printf '%q %s\n' "$(basename "$1")" '--foo bar /tmp/foobar'
}

isTestOnly=
isAll=
isInplace=
typeset -a patchArgs=()
typeset -a patchInplaceArgs=(--output=-)
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	    shift; printLongUsage "$0"; exit 0;;
	--in-place)	    shift; isInplace=t; patchInplaceArgs=();;
	--inplace=*)	    isInplace=t; patchInplaceArgs=(--backup --suffix="${1#--inplace=}"); shift;;
	-i*)		    isInplace=t; patchInplaceArgs=(--backup --suffix="${1#-i}"); shift;;
	--test-only|-t)	    shift; isTestOnly=t;;
	--all)		    shift; isAll=t;;

	-+([ceElnTuZ]))	    patchArgs+=("$1"); shift;;
	-p*)		    patchArgs+=("$1"); shift;;
	--@(backup-if-mismatch|no-backup-if-mismatch|binary|context|ed|remove-empty-files|ignore-whitespace|merge|normal|posix|follow-symlinks|set-time|unified|verbose|set-utc))
			    patchArgs+=("$1"); shift;;
	-[dDFgprV])	    patchArgs+=("$1" "$2"); shift; shift;;
	--@(directory|ifdef|fuzz|get|merge|strip|reject-file|read-only|reject-format|version-control)=*)
			    patchArgs+=("$1"); shift;;
	--@(directory|ifdef|fuzz|get|strip|reject-file|read-only|reject-format|version-control))
			    patchArgs+=("$1" "$2"); shift; shift;;

	--)		    shift; break;;
	-*)		    { echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		    break;;
    esac
done

if [ $# -eq 0 ]; then
    echo 'ERROR: No PATCH passed.'
    echo
    printUsage "$0"
    exit 2
elif [ "$isInplace" ] && [ "$isTestOnly" ]; then
    echo 'ERROR: Cannot combine --in-place and --test-only.'
    echo
    printUsage "$0"
    exit 2
fi >&2

doPatch()
{
    patch --batch --silent "${patchInplaceArgs[@]}" "$@"
}

status=
for patchFilespec
do
    doPatch --forward --read-only=fail --reject-file=- --input "$patchFilespec"
    case $? in
	0)  : ${status:=0};;
	1)  if [ ${status:-4} -le 1 ] && doPatch --reverse --dry-run --read-only=fail --reject-file=- --input "$patchFilespec"; then
		status=1
	    elif [ ${status:-4} -le 4 ] && [ "$isAll" ]; then
		status=4
	    fi
	    ;;
	2)  status=5;;
	*)  status=3;;
    esac
done
exit ${status:-4}
