#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Print file contents on standard output line per line with delay.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--initial NUMBER[SUFFIX]] [--line NUMBER[SUFFIX]] [--char NUMBER[SUFFIX]] FILE [...] [-?|-h|--help]'
    printf 'Usage: cat FILE [...] | %q %s\n' "$(basename "$1")" '[...] [-?|-h|--help]'
}

initialDelay=
lineDelay=
charDelay=
consumer=
linePrinter='printf %s'
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--initial)	shift; initialDelay="$1"; shift;;
	--line)		shift; lineDelay="$1"; shift; consumer=lineDelay;;
	--char)		shift; charDelay="$1"; shift; linePrinter=charDelay;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
[ -n "$charDelay" -a -z "$consumer" ] && consumer=lineReader



lineReader()
{
    while IFS=$'\n' read -r line || [ -n "$line" ]
    do
	$linePrinter "$line"
	printf '\n'
    done
}

lineDelay()
{
    while IFS=$'\r' read -ra lines || [ ${#lines[@]} -gt 0 ]
    do
	let cnt=0
	for line in "${lines[@]}"
	do
	    let cnt+=1

	    # Return to the first column before printing a subsequent internal line
	    # fragment.
	    [[ $cnt > 1 ]] && printf '\r'

	    $linePrinter "$line"

	    # Conclude the last line fragment with a newline.
	    [[ $cnt = ${#lines[@]} ]] && printf '\n'

	    sleep "$lineDelay"
	done
    done
}

charDelay()
{
    local line="$1"; shift
    local i
    for ((i = 0; i < ${#line}; i++))
    do
	printf %s "${line:i:1}"

	sleep "$charDelay"
    done
}

[ "$initialDelay" ] && sleep "$initialDelay"
eval cat '"$@"' "${consumer:+|} $consumer"
