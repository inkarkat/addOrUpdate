#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: echo COMMANDLINES | %q %s\n' "$(basename "$1")" '[-g|--memoize-group GROUP] [--bare|[--trailing-prompt] [--no-output-no-prompt] [--no-output-no-error] [--no-success-no-count] [--emulate-prompt] [--worst-status] [-c|--comment COMMENT]] [--recheck-at-end] [--recheck-at-checkpoints] [--] EXECUTABLE [-?|-h|--help]'
    printf 'Usage: %q %s <<EOF\n  COMMANDS\nEOF\n' "$(basename "$1")" '[...] EXECUTABLE'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Checks whether the passed EXECUTABLE exists in PATH. If not, it asks the user
whether to define it. If confirmed, this will execute the shell COMMANDS read
from stdin.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --recheck-at-end	will perform a second check after all COMMANDS have been
			read; if it fails, an error is printed and this command
			will fail.
    --recheck-at-checkpoints    defines a custom "checkpoint" command that can
				be included anywhere in COMMANDS to do a check.
				A successful check will abort additional
				COMMANDS.
HELPTEXT
}
isBare=
isRecheckAtEnd=
isRecheckAtCheckpoints=
typeset -a checkpointPrePipeline=()
typeset -a memoizeDecisionArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		    shift; printLongUsage "$0"; exit 0;;
	--bare)			    shift; isBare=t;;
	--memoize-group|-g)	    memoizeDecisionArgs+=("$1" "$2"); shift; shift;;
	--recheck-at-end)	    shift; isRecheckAtEnd=t;;
	--recheck-at-checkpoints)   shift; isRecheckAtCheckpoints=t;;
	--)			    memoizeDecisionArgs+=("$1"); break;;
	*)			    break;;
    esac
done
if [ $# -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi
EXECUTABLE=; [ $# -gt 0 ] && EXECUTABLE=${!#}
typeset -a runWithPromptArgs=("${@:1:$(($#-1))}")
if [ "$isRecheckAtCheckpoints" ]; then
    printf -v quotedExecutable '%q' "$EXECUTABLE"
    checkpointPrePipeline=(sed -e "1i\\checkpoint() { 'which' ${quotedExecutable//\\/\\\\} >/dev/null 2>&1 && exit 0; }")
fi
[ "$memoizeDecisionArgs" ] || memoizeDecisionArgs=(--memoize-group "$(basename -- "$0").$PPID")

check()
{
    'which' "$EXECUTABLE" >/dev/null 2>&1
}
check && exit 0

memoizeDecision "${memoizeDecisionArgs[@]}" --subject "$EXECUTABLE" --state 'exist' --action 'define it' || exit 2

runInput()
{
    if [ "$isBare" ]; then
	bash -
    else
	runWithPrompt --no-trailing-prompt
    fi
}
eval '"${checkpointPrePipeline[@]}"' "${checkpointPrePipeline:+|}" runInput
status=$?

if [ "$isRecheckAtEnd" ]; then
    if ! check; then
	printf 'ERROR: %s still does not exist.\n' "$EXECUTABLE"
	if [ $status -eq 0 ]; then
	    exit 1
	else
	    exit $status
	fi
    fi
fi

exit $status
